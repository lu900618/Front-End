---
title: ES6
date: 2018/04/01
author: 32401545@qq.com
modify: 2018/04/07
---
# ES6/7 实用功能

> [阮一峰](http://es6.ruanyifeng.com/)

## 1.强化对必须参数的要求

ES6 提供了**默认参数**，支持设置默认值，以便在没有该参数的情况下调用该函数。默认参数的顺序是在非默认参数之后。

```js
const required = ()=>{throw new Error('Missing parameter')}
const add = (a = required(), b = required()) => a + b

add(1, 2) // 3
add(1) // Error: Missing parameter
```

## 2.reduce

Array 的 reduce 方法适用范围非常广泛，通常用于将一组数据转为单一的值。其实还可以做更多事。

> 注：大多数技巧都依赖于初始值的形态，它是数组或对象，而不是像字符串或变量这样的简单值。

### 2.1 使用 reduce 同时进行映射和过滤

假设有么这一个用例，有一个列表，你想修改其中的每一项（也就是映射）然后过筛选来其中一些（即过滤）。这个过程需要你对列表进行两次遍历！

下面这个示例中，我们把数组中的每项的值翻倍，然后选出所有大于 50 的值。注意，我们是如何使用强大的 reduce 方法来同时进行翻倍（映射）和过滤的？那是非常有效的办法。

```js
const numbers = [10, 20, 30, 40]
const doubleOver50 = numbers.reduce((finalList, num) => {
  num = num * 2
  if(num > 50){
    finalList.push(num)
  }
  return finalList
}, [])

doubleOver50;
```

### 2.2 使用 "reduce" 代替 "map" 或 "filter"

### 2.3 使用 reduce 匹配括号Using reduce to balance parentheses

这里还有一个关于 reduce 普适性的例子。有一个包括括号的字符串，我们知道这些括号是否都相互匹配，即“(”和“)”的数量是否相等，而且“(”是否在“)”之前出现。

我们可以像下面这样用 reduce 轻松解决。我们需要一个叫 counter 的变量用作计数器，其初始值为 0。如果我们遇到 ( 就加 1，遇到 ) 就减 1。如果它们完全匹配，我们最后会得到一个 0 值。

```js
// Return 0 if balanced
const isParentBalanced = str => {
  return str.split('').reduce((counter, char) => {
    if (counter < 0) { // matched ')' before '('
      return counter
    } else if (char === '(') {
      return ++counter
    } else if (char === ')') {
      return --counter
    } else {
      return counter
    }
  }, 0)
}

isParentBalanced('(())') // 0
isParentBalanced('(asdasd)') // 0
isParentBalanced('(()') // 1
isParentBalanced(')(') // -1
```

### 2.4 统计数组中重复数据 (数组 → 对象转换)

有时你需要统计数组中重复的数据，或将数组转换为对象，你就可以使用reduce了。
以下案例，我们将要统计有多少种类的汽车类型并将这些数据放置到一个对象中。

```js
var cars = ['BMW', 'Benz', 'Benz', 'Tesla', 'BMW', 'Toyota']
var carsObj = cars.reduce(function(obj, name){
  obj[name] = obj[name] ? ++obj[name] : 1
  return obj
}, {})

carsObj; // {BMW: 2, Benz: 2, Tesla: 1, Toyota: 1}
```

此外，reduce还有很多方面的应用，我推荐你阅读[MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)所示的案例。

## 3.对象解构

### 3.1 删除不想要的属性

很多时候，当你想要删除不想要的属性——可能会因为他们包含敏感信息或者就是因为他们太大了。在 *rest* 参数中，除了迭代整个对象来删除他们这个方法之外，我们还可以简单地提取这些属性变量，以保持有用的。

在下面例子中，我们想要删除 `_internal` 和 `tooBig` 属性。我们会给 `_internal` 和 `tooBig` 变量赋值并存储，之后，我们再使用 *rest* 参数 cleanObject 。

```js
let (_internal, tooBig, ...cleanObject) = {el1: '1', _internal: 'secret', tooBig: {}, el2: '2', el3: '3'}
console.log(cleanObject) // {el1: '1', el2: '2', el3: '3'}
```

### 3.2 在函数参数中使用解构

下面的示例中的 engine 属性是 car 对象中的一个嵌入对象。如果说我们需要 engine 的 vin 属性的话，可以像下面这样使用解构轻松实现。

```js
const car = {
  model: 'bmw 2018',
  engine: {
    v6: true,
    turbo: true,
    vin: 12345
  }
}

const modelAndVIN = ({model, engine: {vin}}) => {
  console.log(`model: ${model} vin: ${vin}`)
}

modelAndVIN(car); // "model: bmw 2018 vin: 12345"
```

### 3.3 合并对象

ES6 带来了扩展运算符（用 3 个点表示）。它通常用于解构数组的值，不过它也可以用在对象上。

下面的例子中，我们新对象中使用扩展运算符来扩展对象。第 2 个对象中的键值对会覆盖第 1 个对象中的键值对 [译者注：如果键名相同的话]。

下面示例中第 object2 的 b 和 c 两个键值对覆盖了 object1 中的同名键值对。

```js
let obj1 = {a: 1, b: 2}
let obj2 = {b: 20, c: 30}
let merged = {...obj1, ...obj2}
console.log(merged) // {a: 1, b: 20, c: 30}
```

## 4.Set

### 4.1 使用 Set 去重

```js
let arr = [1, 1, 2, 2, 3, 3]
let deduped = [...new Set(arr)] // [1, 2, 3]
```

### 4.2 使用数组的方法

将Sets转换为数组只需要简单的使用的一个展开运算符(… )。同时你也能在Sets里使用所有数组相关的方法。

如以下Set，我们只想保留所有大于3的数据（过滤不匹配的数据）

```js
let mySet = new Set([1, 2, 3, 4, 5])
var filtered  = [...mySet].filter(x => x > 3)
```

## 5.数据解构

## 5.1 交换值

```js
let param1 = 1
let param2 = 2
[param1, param2] = [param2, param1]
```

## 5.2 从一个函数中接收和赋值多个值

```js
async function getFullPost() {
  return await Promise.all([
    fetch('/post')
    fetch('/comments')
  ]);
}
const [post, comments] = getFullPost()
```

## 6. ES7 - 确定一个元素是否在数组中存在

**Array.prototype.includes()**

```js
let arr = ['my','mom','hates','me']
arr.includes('mom') // true
```
